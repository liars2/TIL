통합
======

앞서 말한, 느슨한 결합 그리고 강한 응집력을 얻기 위하여 서비스 분류를 한 이유는 통합을 위해서 라고 말할 수 있다.

그러면, 서비스와 서비스 끼리의 결합은 어떤 방식으로 할 수 있을까?

선택권의 자율성
---------------------------------------

### 서버가 바뀌어도 클라이언트가 바뀌면 안된다.
    메이저 업그레이드로 데이터 일부분에 몇 가지 새로운 것을 추가하고 노출하여도 기존 서비스에 영향을 미치지 않아야 한다.

### API는 모든 기술에 일정해야한다
    기술의 발전으로 문자 메시지(SMS)만 추구하던 옛 시스템과 달리 카카오톡이나 기타 메신저의 발달로 기술의 발전이 있다는 것을 볼 수 있다.
    상당히 짧은 시간에 많은 변화가 일어나고 있는데, 다음날에 우리가 사용한다는 기술을 계속 사용한다고 보장할 수 있을까?

> 마이크로서비스의 모든 API 통신은 특정 기술만 사용해야한다 라는 고집이 없다.

**이는 마이크로서비스가 기술 스택을 좌우하는 기술 지향 아키텍쳐가 아니라는 것도 증명한다.**

### TO KISS (KEEP IT SIMPLE STUPID) CUSTOMER

    마트가 미로같고 아무런 정보 및 안내 없이 물건들을 내세우면 그 마트는 어떻게 되겠는가?
    우리의 서비스를 이용하는데 난잡하고 수고를 들어야 한다면 그 서비스는 성공하겠는가?

그러면 어떻게 쉽게 사용할 수 있을까?

클라이언트 라이브러리를 제공하는 것이 손쉬운 대안이지만, 늘어난 결합의 비용을 초래한다.

### 굳이 다 보여줄 필요는 없다

    내부까지 보여준다면, 그 서비스의 내부까지 종속되게 만들 것이며,
    결국에는 우리가 그토록 신경쓴 결합도도 높아지게 된다.

그래서, 소비자 업그레이드가 두려워서 변경을 꺼리게 되며, 기술 부채 증가를 가져온다.

#### 기술 부채

    기술 비전을 충실히 이행하지 못하는 경우, 예를들어 긴급한 배포를 위해 절차를 무시한 것
    이럴 경우에는 기술 부채라는 것이 쌓인다.

이것이 꼭 배포와 관련된 것이 아니더라도 비동기 처리, 코드 인덴트, 테스트 코드 작성 등등..

비지니스가 우선 업무로 이행 해야만 할 때 이와 같은 **부채가 쌓인다.**


### 공유 데이터 베이스
    일반적인 통합 형태는 DB 통합이다.
    어떤 서비스가 어떤 데이터를 원하면 직접 접근하여야 한다, 정보를 변경하고자 할때도 마찬가지다.
<img src="../Image/Using DB Integration to access and change customer information.PNG">

1. 도메인 외부에서 내부의 구현 상세를 조회하고 결합하는 것을 용한다.
2. 소비자들이 특정 기술을 선택하는 범위가 제한된다.
3. 고객 정보가 변경되는 방식과 관련한 로직이 어딘가에 있을까? 만약 소비자가 DB를 직접 조작한다면 소비자는 로직을 소유해야하고 Domain 의 경계를 넘어 결국 응집력을 발휘할 수 없다

강한 응집력과 느슨한 결합력이 마이크로 서비스의 핵심 원칙이지만, 데이터 베이스 통합에서는 모두 다 잃어버린다.

### 오케스트레이션과 코레오그래피

#### 오케스트레이션
    오케스트라 지위자 처럼 프로세스를 안내하는 것 같아서 오케스트레이션이라고 불린다.

오케스트레이션 뇌 처럼 작동하는 형식이다.
배고프다 -> 냉장고를 열어본다 -> 과일을 발견한다 -> 과일을 먹는다.

#### 코레오그래피
    발레 무용수들이 자신의 역활을 알고 주변의 다른 무용수에 반응하는 것처럼 해서 코레오그래피라고 불린다.

코레오그래피는 비동식으로 이벤트를 발생할 뿐이다.
다른 서비스들이 그것을 지켜보고, 이벤트가 발생하면 그것에 발맞춰 대응하는 형태다.

하지만, 이 뜻은 다른 서비스들이 제대로 잘 하고 있나에 관해 모니터링 시스템이 필요하다는 것을 의미하곤 하다.

RPC
-------------

    원격 프로시저호출(RPC)는 지역 호출을 통해 원격 서버스를 실행하는 기술이다.
    RPC를 통해 페이로드를 마샬링 혹은 언마샬링 하는 비용이 크더라도, 네트워크 전송 시간에 비할 바는 아니다.

### 지역 호출은 원격 호출과 다르다

    RPC 아이디어의 핵심은 원격 호출 복잡성을 은폐하는 것이지만, 지나치계 은폐한다.

RPC의 일부 형태는 원격 호출을 마치 지역 호출 처럼 보이게 추상화 하여 만들어서 큰 차이를 감춘다.
최악의 경우, 추상화덕에 지나치게 불투명하다면 개발자는 서비스 경계를 알지 못한 채 원격 호출을 사용할 수 있다.

### RPC는 좋은 것인가?

    RPC가 위와 같은 문제들만 조성한다면 많은 연산작업을 하는 모델들은 RPC에 적합하며
    RPC의 요청/응답의 협업 방식의 측면에서 보면 확실히 DB 통합보다 개선되었다.

REST
--------------

    REST(Representational State Transfer)는 웹에서 영감을 얻은 아키텍쳐다.
    HTTP Method인 GET, POST, PUT, UPDATE.. 으로 작동한다.

### 자원

    REST에서는 자원이란 개념을 사용하는데
    Customer처럼 스스로 알고 있는 것을 자원으로 간주할 수 있다.

### 하이퍼 미디어 제약

    애플리케이션 상태는 하이퍼미디어로 변경된다

애플리케이션은 클라이언트에 의해 변경되는 책임이 있고, 클라이언트는 하이퍼 미디어 컨트롤러로 변경할 수 있기 때문이다.

### 노페인 노게인

    RESTful 웹 서비스 생성을 도와주는 프레임워크 역시 인기를 얻고 있었는데 (편리함과 간편함 때문에)
    단기적으론 득이 되지만, 장기적으론 독이 된다.

일부 프레임워크는 객체의 DB표현을 바로 전달받아 프로세스 내의 객체로 역직렬화
외부로 직접 노출하는 일련의 작업을 매우 쉽게 만든다.

### HTTP REST 단점

1. REST 애플리케이션 프로토콜용 클라이언트 스텁은 RPC에서 한 것처럼 쉽게 생성되지 않음.
2. HTTP 메서드를 제대로 지원하지 않음 (PUT, DELETE)
3. JSON 혹은 Binary 포멧을 지원하는데, 보기엔 간결해 보이지만 쓰리프트(Apach)같은 프로토콜 보다 느리다
4. HTTP 요청에서 발생하는 HTTP 부하

비동기 이벤트 기반
--------------------

### 기술 선택
    마이크로서비스가 이벤트를 발산하는 방법, 소비자가 생성된 이벤트를 찾는 방법을 찾아야 한다.

RabbitMQ (Using AMQP Protocol)와 같은 중계자들은 두 문제를 모두 처리한다.

> 생산자는 API를 사용해 브로커에 이벤트 발행 -> 소비자에게 알릴 수 있도록 구독을 처리

또 소비자 문제도 해결 가능하다

> 소비자가 이전에 확인했던 메시지를 추적

중개자 시스템은 확장 및 회복이 가능하도록 설계되었지만, 개발하고 테스트하기 위해 실행해야 하는 또 다른 시스템인 만큼 개발 과정에 복잡성이 높아진다.

메시지 큐는 작더라도 신경을 써야하는데, 이 메시지 큐를 사용하는 사용자들은 대부분 패키징 하려는 경향이 있어 더 많은 메시지를 미들웨어에 추가함

그러면 '미들웨어를 멍청하게, 엔드포인트를 지능적으로.' 라는 원칙을 깸

#### 미들웨어를 멍청하게 엔드포인트를 지능적으로

    미들웨어/인프라스트럭처에 메시지를 비동기적으로 라우팅할 수 있을 정도로 단순하게 구현하고,
    엔드포인트의 서비스에 메시지를 생성하고 소비하는 복잡한 로직을 구현한 방식

### 비동기 아키텍처의 복잡성

    노드 다운, 오랜 응답 시간, 정보 저장후 후에 다시 동작하는 여러가지 대응을 해야만 한다.

만약 두 지점간의 요청/응답으로 진행하는 API 도중에 보기가 힘들다면,
**이 하나하나 들을 Unique 한 ID로 만들어 관리해야한다.**

마이크로서비스는 도메인의 양식 및 로직을 소유한다
--------------------------------------------------

    소비자가 원하는 결과를 얻으려고 서비스에 요청을 보낼 때,
    서비스는 자신의 로직을 기반으로, 요청의 수용 여부를 결정하고 소비자와 연관된 이벤트의 수명주기를 통제한다.

단순한 CRUD 래퍼로 구현됬으면, 외부에서 요청을 할 수 있을 것이며 결과적으로 응집력을 잃은 것 이다.

반응형 확장
----------

    Rx로 알려진 반응형 확장은 다수의 호출 결과를 조합하고 그 결과에 따라 연산을 실행하는 메커니즘이다.
    이들 호출은 자체로 블록킹 혹은 논블로킹 호출이 될 수 있다.

데이터를 요청하는 대신에, 데이터에 대한 연산을 수행후 결과를 관찰하고 변경에 따라 반응한다.

더 많은 서비스를 호출하게 될 떄, 하나의 작업을 수행하기 위해 다수의 호출이 필요할 때 좋다.

### 반응형 프로그래밍
    전통적인 제어의 흐름이 아니라, 입력에 반응하여 동작하는 이벤트 기반 프로그래밍

소프트웨어 개발 원칙 DRY(Don't Repeat Yourself)는 꼭 지켜야 하는 것인가?
-------------------------------------------------

    소프트웨어 개발 원칙중에 DRY라고 스스로 반복하는 코드를 짜지 말라는 의미로 DRY라고 많이 부르는데.
    DRY가 중복된 코드를 회피하는 시도로 단순하게 정의되지만, 명확하게 정의하면 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도라고 할 수 있다.

> 물론, 원칙 중 하나인 만큼 합리적인 충고다.

**일반적으로 동일 작업을 수행하는 라인이 많으면 코드베이스가 커져, 추적하기 힘들다.**

DRY를 통해 재사용할 수 있는 코드를 만들어 추상화하고 또 공유 라이브러리로도 만들 수 있지만

지나친 결합으로 인한 문제가 발생 할 수 있다.

공유 코드를 서비스 경계(Bounded context)를 넘어 사용한다면, 그것은 이미 지나친 결합을 초래하는 원인이 된다.

참조에 의한 접근
---------------
어떤 도메인의 대한 정보를 참조 했을 때, 그 정보를 나머지가 참조 할 수 있고
그랬을 때 그 서버에 올라와 있는 메모리는 틀릴 수 있다.

그래서 이벤트가 발생 했을때 이벤트 전, 후의 상태도 알아야 한다.

버전 관리
----------
> 서비스가 제일 안정적인 상태는, 출시 상태에서 아무것도 업데이트 하지 않은 상태다.

호환성을 깨트리지 않으며, 버전관리를 하는 것은 매우 중요하다.

### 유의적 버전 관리

    업데이트 번호만 보고 해당 서비스와 통합 가능한지 알 수 있을까?
    그것을 가능하게 하는 명세가 존재한다.

MAJOR.MINER.PATCH 형태로 버전을 관리한다.

MAJOR: 하위호환성이 깨진 것(하위호환성이랑 상관이 없으면)
MINER: 하위 호환성을 우지하면서 새 기능 추가
PATCH: 기존 기능의 BugFix

### 충격 제한하기

    만약, 하위호환성을 깨트리는 릴리즈를 하려고 한다면
    구버전의 엔드포인트와 신버전의 엔드포인트를 공존하면 된다.

이 방식으로, 새로운 인터페이스를 가진 마이크로서비스를 가능한 빨리 출시 할 수 있다.

> 구버전을 공존하는 이유는, 사용자에게 변화할 시간을 주기 위해

다수의 병행 서비스 버전 모두 사용하기
--------------------------------

    오래된 소비자를 변경하는 비용이 높을 때 사용하는 방법으로,
    짧은 기간 동안 병행 서비스를 운영한다.

보통, BLUE/GREEN 릴리즈 혹은 카나리아 릴리즈를 할 때 이 방법을 사용한다.

사용자 Interface
-----------------

    서비스를 제공하는 다양한 기능 요소를 한데 엮을 수 있는 구성 가능한 계층.
    고객(해당 서비스를 사용하는 서비스도 포함)을 이해시키기 위해 모든 마이크로서비스가 협력하는 곳이다.

그렇다면, 어떻게 엮을 수 있을까?

### 제약

    사용자가 시스템과 상호작용하는 또 다른 형태.

ex) 데스크톱 웹 에플리케이션에는 방문자가 사용하는 브라우저의 종류와 해상도 등의 제약이 존재, 모바일도 마찬가지.

### API 구성

    서버에서 XML과 JSON으로 통신할 때, GET과 POST로 서로 통신한다면 Native Mobile 에서도 간단히 할 수 있다.
    그 다음 UI는 인터페이스를 구상하는 다양한 컴포넌트들을 생성하고 서버와 상태 등의 동기화를 처리해야 한다.

> 서비스 대 서비스 통시능 ㄹ위해 바이너리 프로토콜을 사용했다면 웹 기반의 클라이언트에는 적용이 어렵겠지만, 모바일 디바이스에서 적용하는 것은 괜찮다.

하지만 이 접근 방식에는 몇 가지 단점이 존재함.
1. 다양한 종류의 디바이스에 맞춤화된 응답 능력이 거의 없음
    - 해결책은 오직, 소비자가 요청할 때 되돌려 받을 필드를 명시하는 것 밖에 없음

2. 누가 사용자의 인터페이스를 생성해야하는가가 정해지지 않음
    - 다른팀이 UI를 생성한다면, 작은 변경 하나도 여러 팀에 물어봐야하는 상황이 벌어짐

3. 서비스에 직접적으로 수많은 호출을 하는 것은 모바일 기기에 꽤 부담이 될 수 있음.
    - API 게이트웨이를 사용하면 도움이 될 수 있다.

### UI 부분 구성

    UI가 API를 호출, UI 컨트롤과 매핑한 일부 UI를 직접 제공할 수 있다.

외부 소프트웨어와 통합
------------------------

    모든 것을 통합하기 위해서는, 우리가 감당하고 변경할 수 있는 시스템들만 하는 것도 아니라 외부 소프트웨어도 통합해야하는 경우가 있다
    우리가 직접 만든 것이 아닌 서비스 같은 경우엔 어떻게 통합하는가?


### 교살자 패턴

    완전한 통제권이 없는 레거시 플랫폼 또는 상용 플랫폼의 경우 제거하거나
    그러부터 이전하려 할 때 발생하는 문제를 잘 처리해야 한다.

> 이 때 유용한 패턴이, 교살자 애플리케이션 패턴이다.

보통 람다로 기존 코드의 호출을 잡아내 하나씩 교체해가는 형식으로 구성된다.