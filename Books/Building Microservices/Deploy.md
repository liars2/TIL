배포
==============

    최종 사용자에게 소프트웨어를 전달하는 과정을 배포라고 한다.
    모놀리식 애플리케이션의 배포는 간단하지만, 상호 의존성을 중시하는 마이크로서비스의 배포와는 전혀 다르다.

CI
---

    지속적 통합(Continuous Intergration)은 퀄리티 컨트롤을 적용하는 프로세스를 실행시키는 것이다.
    개발 관점에서 보면, 지속적으로 작성해온 코드베이스를 합쳐 서비스에 올리는 것이다.

### CI가 필요한 이유

    CI를 하지 않는다면 다음과 같은 문제 상황이 발생한다.

1. 다른사람과 동기를(서비스의 코드) 맞추지 않아, 완전히 서로 다르거나 혹은 이미 구현한 컴포넌트등 침해할 수 있음

2. 지속적으로 하지 않는다면, 릴리즈 주기가 매우 길어져 사용자들에게 서비스를 보여주지 못하는 상황이 발생

3. 배포하는데 도구 혹은 절차가 존재하지 않는다면 릴리즈 하는데도 비용과 시간이 많이 든다.

[위와 같이 혼돈의 상황을 Hell이라고 부르는걸 좋아하는 서양 문화 답게 통합의 지옥이라고 부른다.](http://c2.com/cgi/wiki?IntegrationHell)

```CI를 한다면 이런 이점을 얻을 수 있다.```

1. 코드 품질에 대한 빠른 피드백을 얻을 수 있다.

2. 산출물의 빌드를 위한 모든 코드는 버전 관리되므로 언제든지 다시 만들 수 있다.

3. CI 도구 자체의 기능에 따라 어떤 테스트를 하였는지 확인 할 수 있다.


### CI의 동작방식

    코드베이스에서 주 브런치에 Commit이 된다면, 해당 커밋에 대한 테스트와 각가지 단계를 파이프라인으로 다루어 배포를 한다.

#### 파이프라인?

    파이프라인(Pipe Line)이라는 용어는 많이 사용되는데, 개발에서의 파이프라인 혹은 단계에서의 파이프라인 등등 사용되는데,
    이 전 단계의 결과 값을 다음 작업으로 넘겨주는것을 파이프라인이라고 한다.

> Ex) 프라미스 체인도 파이프라인이다.
```
Promise(() => pseudoAsync()).then(...).then(...).then(...)
```

### 빌드 파이프 라인 동작 과정

    일반적인 빌드 파이프 라인 동작 과정은 이와 같다.

> 컴파일과 빠른 테스트(유닛 테스트) -> 느린 테스트(통합 테스트) -> UAT(사용자 인수 테스트) -> 성능 테스트 -> 실환경 배포

**서비스는 모든 다양한 환경에서 동일해야 한다.**

#### UAT 사용자 인수 테스트

    시스템이 실제 운영 환경에서 준비가 되었는지 최종적으로 확인하는 단계

사용자가 테스트를 해서 잘못된 점이나 이해가 상충되는 부분을 확인, 테스트 하는 절차이다.

### CI 도구와 CI는 다르다.

    위와 같은 도구들을 사용한다고 해서 CI를 실천한다고 할 수 있을까?
    제즈 험블의 3가지로 CI를 사용하고 있는건지 CI 도구만 사용하는 건지 알 수 있다.

##### 1. 하루에 한 번 메인 브랜치에 체크인하는가?

    여러분의 코드는 물론, 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 통합이 더 어려워 진다.
    변경을 위해 단기 브랜치를 사용하여도 메인 브랜치에 통합해라.

##### 2. 변경을 확인할 테스트 집합이 있는가?

    테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것 까지는 알 수 없다.
    코드가 기재한 댜로 동작하는지 검증하지 않는 CI는 CI가 아니다.

##### 3. 빌드가 깨졌을 때 팀이 그것을 최우선으로 하는가?

    녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미한다.

빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다.


모놀리식 서비스는 큰 통합 서비스, 마이크로서비스는 분활 통합 서비스???
---------------------------------------------------

    기존 모놀리식 서비스는 충돌만 고려하면서 서비스를 운영만 하였으면 됬었다.
    하지만, 마이크로서비스는 모든 서비스를 고려하면서 배포해야 한다, 좋은 방법이 있을까?

몇 가지 방법이 있는데, 가장 단순한 방법은 하나로 엮는것이다.

지속적으로 통합하는 서버를 만들어서, 커밋이 있을 때 마다 해당 소스코드를 모두다 가져와 빌드 하는 것이다.

이것을 락스텝 릴리즈라고 한다.

```
Object 예제
CI_BUILD_LIST
[
  { Name: A, Source: 1, Version: 1.3 },
  { Name: B, Source: 2, Version: 1.3 },
  { Name: C, Source: 3, Version: 1.3 }
]

위에 예제의 Source가 숫자로 나타낸다고 하자, 만약에 B의 소스가 업데이트 되어 4로 됬다면 해당 빌드는 이렇게 변한다.

CI_BUILD_LIST
[
  { Name: A, Source: 1, Version: 2.4 },
  { Name: B, Source: 4, Version: 2.4 },
  { Name: C, Source: 3, Version: 2.4 }
]

이렇게 된다면, 한 서비스의 일부분만 바꿔도 모두다 빌드한다는 단점이 있다.
```

테스트할 필요가 없는 것까지 테스트하므로 실제로 필요 이상의 시간이 소요될 수 있다.

> 이것은 하나의 변경을 개발에서 실운영환경에 전달하는 속도, 즉 순환 시간에 영향을 준다.

이런 방법을 개선하기 위해, CI 빌드가 한가지의 서비스만 빌드 하도록 하면 된다.

```
Object 예제

USER-SERVICE-BUILD = { Name: USER, Source: 1, Version 0.1 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이런식으로 단일 산출물을 만들 수 있다, 그래서 앞서 말한 한 서비스의 일부분 업데이트여도

USER-SERVICE-BUILD = { Name: USER, Source: 3023, Version 4.9 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이렇게, 한 가지 서비스만 수행하고 배포할 하나의 산출문만 얻는다.
```