배포
==============

    최종 사용자에게 소프트웨어를 전달하는 과정을 배포라고 한다.
    모놀리식 애플리케이션의 배포는 간단하지만, 상호 의존성을 중시하는 마이크로서비스의 배포와는 전혀 다르다.

CI
---

    지속적 통합(Continuous Intergration)은 퀄리티 컨트롤을 적용하는 프로세스를 실행시키는 것이다.
    개발 관점에서 보면, 지속적으로 작성해온 코드베이스를 합쳐 서비스에 올리는 것이다.

### CI가 필요한 이유

    CI를 하지 않는다면 다음과 같은 문제 상황이 발생한다.

1. 다른사람과 동기를(서비스의 코드) 맞추지 않아, 완전히 서로 다르거나 혹은 이미 구현한 컴포넌트등 침해할 수 있음

2. 지속적으로 하지 않는다면, 릴리즈 주기가 매우 길어져 사용자들에게 서비스를 보여주지 못하는 상황이 발생

3. 배포하는데 도구 혹은 절차가 존재하지 않는다면 릴리즈 하는데도 비용과 시간이 많이 든다.

[위와 같이 혼돈의 상황을 Hell이라고 부르는걸 좋아하는 서양 문화 답게 통합의 지옥이라고 부른다.](http://c2.com/cgi/wiki?IntegrationHell)

```CI를 한다면 이런 이점을 얻을 수 있다.```

1. 코드 품질에 대한 빠른 피드백을 얻을 수 있다.

2. 산출물의 빌드를 위한 모든 코드는 버전 관리되므로 언제든지 다시 만들 수 있다.

3. CI 도구 자체의 기능에 따라 어떤 테스트를 하였는지 확인 할 수 있다.


### CI의 동작방식

    코드베이스에서 주 브런치에 Commit이 된다면, 해당 커밋에 대한 테스트와 각가지 단계를 파이프라인으로 다루어 배포를 한다.

#### 파이프라인?

    파이프라인(Pipe Line)이라는 용어는 많이 사용되는데, 개발에서의 파이프라인 혹은 단계에서의 파이프라인 등등 사용되는데,
    이 전 단계의 결과 값을 다음 작업으로 넘겨주는것을 파이프라인이라고 한다.

> Ex) 프라미스 체인도 파이프라인이다.
```
Promise(() => pseudoAsync()).then(...).then(...).then(...)
```

### 빌드 파이프 라인 동작 과정

    일반적인 빌드 파이프 라인 동작 과정은 이와 같다.

> 컴파일과 빠른 테스트(유닛 테스트) -> 느린 테스트(통합 테스트) -> UAT(사용자 인수 테스트) -> 성능 테스트 -> 실환경 배포

**서비스는 모든 다양한 환경에서 동일해야 한다.**

#### UAT 사용자 인수 테스트

    시스템이 실제 운영 환경에서 준비가 되었는지 최종적으로 확인하는 단계

사용자가 테스트를 해서 잘못된 점이나 이해가 상충되는 부분을 확인, 테스트 하는 절차이다.

### CI 도구와 CI는 다르다.

    위와 같은 도구들을 사용한다고 해서 CI를 실천한다고 할 수 있을까?
    제즈 험블의 3가지로 CI를 사용하고 있는건지 CI 도구만 사용하는 건지 알 수 있다.

##### 1. 하루에 한 번 메인 브랜치에 체크인하는가?

    여러분의 코드는 물론, 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 통합이 더 어려워 진다.
    변경을 위해 단기 브랜치를 사용하여도 메인 브랜치에 통합해라.

##### 2. 변경을 확인할 테스트 집합이 있는가?

    테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것 까지는 알 수 없다.
    코드가 기재한 댜로 동작하는지 검증하지 않는 CI는 CI가 아니다.

##### 3. 빌드가 깨졌을 때 팀이 그것을 최우선으로 하는가?

    녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미한다.

빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다.


모놀리식 서비스는 큰 통합 서비스, 마이크로서비스는 분활 통합 서비스???
---------------------------------------------------

    기존 모놀리식 서비스는 충돌만 고려하면서 서비스를 운영만 하였으면 됬었다.
    하지만, 마이크로서비스는 모든 서비스를 고려하면서 배포해야 한다, 좋은 방법이 있을까?

몇 가지 방법이 있는데, 가장 단순한 방법은 하나로 엮는것이다.

지속적으로 통합하는 서버를 만들어서, 커밋이 있을 때 마다 해당 소스코드를 모두다 가져와 빌드 하는 것이다.

이것을 락스텝 릴리즈라고 한다.

```
Object 예제
CI_BUILD_LIST
[
    { Name: A, Source: 1, Version: 1.3 },
    { Name: B, Source: 2, Version: 1.3 },
    { Name: C, Source: 3, Version: 1.3 }
]

위에 예제의 Source가 숫자로 나타낸다고 하자, 만약에 B의 소스가 업데이트 되어 4로 됬다면 해당 빌드는 이렇게 변한다.

CI_BUILD_LIST
[
    { Name: A, Source: 1, Version: 2.4 },
    { Name: B, Source: 4, Version: 2.4 },
    { Name: C, Source: 3, Version: 2.4 }
]

이렇게 된다면, 한 서비스의 일부분만 바꿔도 모두다 빌드한다는 단점이 있다.
```

테스트할 필요가 없는 것까지 테스트하므로 실제로 필요 이상의 시간이 소요될 수 있다.

> 이것은 하나의 변경을 개발에서 실운영환경에 전달하는 속도, 즉 순환 시간에 영향을 준다.

이런 방법을 개선하기 위해, CI 빌드가 한가지의 서비스만 빌드 하도록 하면 된다.

```
Object 예제

USER-SERVICE-BUILD = { Name: USER, Source: 1, Version 0.1 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이런식으로 단일 산출물을 만들 수 있다, 그래서 앞서 말한 한 서비스의 일부분 업데이트여도

USER-SERVICE-BUILD = { Name: USER, Source: 3023, Version 4.9 }
CATALOG-SERVICE-BUILD = { Name: CATALOG, Source: 2, Version 0.3 }
Invoice-SERVICE-BUILD = { Name: INVOICE, Source: 3, Version 0.2 }

이렇게, 한 가지 서비스만 수행하고 배포할 산출물만 얻는다.
```

#### 아이를 반으로 나누거라

    우리가 원하는 필요없는 과정도 생략하고, 서로 다른 빌드를 가질 수 있어 관리하기도 편해졌다.
    근데, 그렇다면 소스 코드 저장소 혹은 이 세세한 서비스들의 관리자는 어떻게 선택할 수 있는가?

간단하다! 각각 코드를 통합한 것으로 가져온 것이 아닌 하나의 코드저장소를 가지게 만들면 된다!

### 지속적 배포(Continuous Delivery)

    지속적 배포는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고,
    나아가 모든 체크인을 빠짐없이 릴리즈 후보로 여기는 접근 방법이다.

CD를 완벽히 지원하는 도구는 소프트웨어의 실환경에 이르는 전체 경로를 모델링하면서 파이프라인들을 정의하고 시각화한다.

소프트웨어의 생산 경로 전체를 모델링함으로써 소프트웨어 품질의 가시성을 크게 향상시키고 개선할 주요 사안인 빌드 및 리리즈 프로세스를 한 곳에서 볼 수 있으므로 릴리즈 간 소요 시간을 크게 줄일 수 있다.

### 앞서 말한 빌드당 서비스가 만병 통치약일까?

    팀이 새로운 프로젝트, 아무것도 없는 무에서 유를 만들 때
    서비스 경계를 확정하는 동안 도메인 개념이 있을 때 까지는 서비스를 큰 부분으로 유지하는 것이 좋다.

이 확정하는 동안, 거의 혼돈의 상태로 서비스가 안팍에 있던게 매일매일 바뀌고 달라지므로, 하나의 빌드로 포함시키는 것이 좋다.

플랫폼별 산출물
-----------------

    대부분의 기술스택들은 서로 다른 확장자를 가지고 있다.
    자바에는 JAR, 루비는 GEM, 파이썬은 Egg .. 등등

하지만 마이크로서비스 관점에서는 기술 스택에 따라 산출물 자체만으로 부족할 수 있다.

자바의 JAR파일을 실행시킨다면 프로세스 매니저를 사용하나등 산출물을 배포하고 실행하기 위해 다른 소프트웨어를 설치하고 구성할 방법도 필요하다.

이러한 산출물들이 특정 기술에 스택에 한정되어 있을 때 생각해보자.

루비 gem, JAR 파일, Node.js , npm 패키지 등 전혀 다른 배포 메커니즘을 사용한다면, 그 기술을 테스트 하려는 사람 혹은 배포 관리자는 지옥을 맛 볼 것이다.

자동화는 하부 산출물의 배포 메커니즘의 차이를 감추는 데 크게 도움이 된다.

운영 체제 산출물
------------------

    특정 기술에 제한적인 산출물과 관련된 문제를 해결할 수 있는 방법은 간단하다.
    운영 체제 네이티브한(Windows MSI, Redhat Linux RPM, Ubuntu deb) 산출물을 생성하면 된다.

이렇게 운영 체제 산출물을 사용한다면, 하부 기술에 대한 것을 신경 쓸 필요 없고 해당 패키지의 도구만 사용하면 된다.

하지만, 이런 방법으로 한다면 굉장히 어려움을 겪거나 단점이 존재한다.

1. FPM으로(리눅스) 패키지리를 만드는 것은 쉽지만, MSI 및 나머지는 만들기가 까다롭다.

2. 다른 운영 체제에 배포를 할 때. 다른 운영체제에서 산출물을 관리하는 일은 부담스러운 일이다.

서버 설치하는데만 30년
----------------------

    자바 애플리케이션 배포를 위해 서버를 프로비저닝 하자고 하였을 때,
    오라클 VM을 설치하는데, 5분 머신이 프로비저닝 되는데 2~3분, JVM을 설치하는데 3분.
    그리고 드디어 우리가 원하는 소프트웨어를 설치 할 수 있다.

소프트웨어는 통계를 위한 콜렉트디, 로그를 위한 로그스태쉬, 모니터링을 위한 나기오스를 적절히 설치...

시간이 지날수록 소프트웨어 설치할 것이 많아지고, 의존성을 가진 것들을 또 프로비저닝 하자면.. 서버 설치만 하다가 끝날 것이다.

물론 퍼펫, 셰프, 앤서블, 그리고 이들의 부류는 이미 설치된 소프트웨어를 재설치하지 않겠지만, 이것을 또 확인하는 작업도 시간이 걸리므로 언제나 빠른 것은 아니다.

그리고, 해당 머신들을 가까이 두면 환경불일치(임의로 설치한 것들로 인해 구성의 차이가 발생하는 것)를 초래하여 피하고자 한다.


