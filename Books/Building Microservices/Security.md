보안
======

    보안은, 위험에 대해서 방호하는 것 혹은 그와 같은 위험에 노출되지 않도록 하는 것을 말한다.
    고객들의 데이터 중심으로 돌아가는 서비스들의 보안은 더할 나위 없이 중요하다.

고객의 데이터야 말로 외부든 내부든 소중한 가치다 그러기 위해서는 보안에 대한 핵심부터 알아야 한다.

핵심을 알기전에, 나는 보안을 설명할 때 '집' 이라는 개념으로 비교를 한다. 앞으로도 집이라는 개념으로 설명을 지속적으로 하겠다.

인증, 권한 부여
---------------

    우리의 소중한 집은 멋진 장물로 가득차있다는 소식을 듣고 도둑들이 우리집을 호시탐탐 노린다고 가정해보자.
    적어도 우리의 대문은 나 그리고 내가 허락한 사람만 열 수 있도록 해야지 않겠는가?

인증은 자신이라고 말하는 당사자를 확인하는 핵심 과정이다. 사람에 대해서는 일반적으로 사용자 이름과 비밀번호를 통해 사용자를 인증한다.

물론 더 복잡한 과정이 있지만, 일반적으로 인증되는 사람 혹은 사물에 대해 추상적으로 이야기 할 때 **권한주체로** 언급된다.

### 권한부여

    권한주체가 있어도, 아무런 권한이 없다면 권한주체가 있던 없던 접근할 수 있는 범위는 같다.
    그래서 특정 서비스 혹은 필요한 서비스에 권한을 부여하는데 마이크로 서비스에서는 어떻게 권한을 분배하는가?

모놀리식 서비스 같은 경우에는 일반적으로 애플리케이션 혹은 프레임워크 상에서 인증과 권한 부여를 처리한다.

하지만 분산 시스템은 여러가지 서비스를 접근할 때 지속적으로 로그인하는 것을 원하지 않을 것이다.

그래서 진보된 전략이 필요하는데, 한 번의 인증으로 모든 시스템을 이용할 수 있는 SSO를 구현하는 것이다.

#### Single-Sign-On

    SSO(Single-Sign-On)은 한 계정으로 여러개의 서비스에 접근이 가능한 구현체 중 하나이다.

대표적으로 구글의 Oauth, 기타 OpenID 라는 개념이 존재하는데. 권한주체가 웹 기반 인터페이스를 통해 리소스를 접근하려고 할 때, 인증을 위해 **신원 제공자에** 재전송 된다.

그렇게 된다면 신원 제공자는 그 사람에게 사용자 이름과 비밀번호를 요구하거나 이중 요소 인증과 같은 더 진보된 것을 요구할 수 있다.

인증이 충족된다면 자원 접근 허용 여부를 결정하도록 **서비스 제공자에게** 정보를 전달한다.

그래서, 마이크로서비스에서 리소스를 얻기 위해서는 **인증을 통해 신원 제공자에게 정보를 전달하고 신원 정보자는 서비스 제공자에게 정보를 요청한다.**

#### Single-Sign-On Gateway

    위처럼, 신원 제공자를 경유하여 데이터를 얻기 때문에 많은 요청이 신원 제공자와 중복된 맺을 것이다.
    공유 라이브러리로 어느정도 해결할 수는 있지만, 이로인해 결합 문제가 생길 수 있으니. SSO 전용 서비스를 사용할 수 있는 게이트웨이를 만들면 된다!


##### 세분화된 권한 부여

게이트웨이는 상당히 효과적인 큰 단위의 인증 기능을 제공하는 것이 가능하다 그에따라 게이트웨이가 권한주체에 대한 속성을 추출할 수 있다고 가정하면 보다 섬세한 결정도 가능하다.

그래서 그룹별로 나누고, STAFF 처럼 특별한 역할을 가진 권한주체만 특정 리소스를 접근할 수 있도록 하는 것도 가능하지만.

팀의 일부 혹은 엔드포인트의 대한 접근 허용 여부는 마이크로서비스 자체에 맡겨야 한다.

어떤 행동의 허용 여부는 마이크로서비스가 더 많이 결정해야할 필요가 있다

서비스가 서비스를 호출하는 과정에서 벌어지는 인증과 권한 부여
-------------------------------------------------------------

    이때까지, 사람에게 권한 주체가 있었고 그에 따른 설명만 하였다.
    하지만, 서비스에게 권한 주체를 설정한다면 다른 서비스 혹은 프로그램이 서로 인증하려면 어떻게 해야 할까?

### 경계안 모든 것을 허락하기

    서비스들을 운영하다보면, 서비스들만 있는 경계가 존재할 것이다.
    그 경계는 외부에서 접근할 수 없고, 그 경계에 있는 서비스들 끼리 권한 유/무와 상관없이 통신하면 안되는가?

데이터 민감도에 따라서 위와 같은 방법은 구현하기 편하고 좋은 방법이 될 수 있다.

하지만, 중간자 공격(MITM)을 사용한다고 하였을 때 당할 수 밖에 없을 것이다.

### HTTP(S) 인증

    HTTP는 기본 인증 시스템을 제공하는데 사용자 정보를 표준 헤더에 넣어 전송하는 것이다.
    널리 알려져 있고, 지원되는 프로토콜이며 HTTPS를 사용하면 중간에 패킷을 가로채도 사용자 정보를 보지 못 할것이다.

하지만, HTTP 인증 구조 구현은 하기가 굉장히 까다로운데 서버가 인증서를 관리하는 것과 관련되어 있기 때문이다.

#### 인증서

    만약에 우리가 명품 도자기를 소유하고 있다면, 이 도자기가 과연 명품인지 증명할 수 있겠는가?
    그래서 제 3자의 개입으로 이 도자기는 가치가 높은 명품 도자기다. 라고 대신 증명할 수 있게 만드는 인증서이다.
    그럼, HTTP에서 이 서버가 과연 신뢰할 수 있는 사이트인가? 라고 하였을 때 증명할 수 있는 방법중 인증서는 안되는가?

HTTP와 HTTPS의 여러가지 차이중에서 하나는, HTTPS는 Secure Socket Layer가 존재한다

이 SSL의 주된 목표는 두개의 의사소통하는 어플리케이션 사이의 개인 정보와 신뢰성을 제공하는데, 그것을 보장하는게 인증서다.

인증서를 발급하기는 꽤 쉽지만, 다음과 같은 문제점이 있다.

1. 서버가 여러 머신을 관리해야한다면 각 서버마다 인증서를 관리해야 하는 추가적인 관리 및 운영 부담이 된다.
2. 자동화된 인증서 관리용 도구가 충분히 성숙하지 못했다. (없는 기능 혹은 제 기능을 못한다.)
3. 자체 서명된 인증서는 쉽게 폐기가 불가능하다
4. 재난 시나리오와 관련해서 더 많은 고민을 해야한다.
    - 재난 상황시 로드 밸런스를 통하여 SSL 트래픽을 중지시키고 캐시로 대체하는 등..

### Using Service Account for SAML or OpenID Connect

    SAML 혹은 OpenID를 사용한다면 사용자는 서비스와 통신하기위해 계정이 존재할 것이다.
    이처럼 서비스는 서비스간의 통신을 위해서 계정을 생성하면 안되는 것인가?

SAML과 OpenID를 구현하여 사용하고 있다면, 서비스 계정을 만들어서 해당 서비스들의 필요한 계정을 생성하여 통신할 수 있는 최소한의 서비스들만의 권한을 설정할 수 있다.

그렇게 된다면 위와 같은 인증서의 문제로 시달릴 필요도 없고, 암묵적인 공격에도 시달릴 필요가 없다.

하지만 몇가지 문제가 존재한다.

1. 기본 인증과 마찬가지로 자격증명을 안전하게 저장해야 한다.
2. 인증 분야의 기술을 코드로 작성하는 업무가 늘어난다.
3. 클라이언트를 SAML로 구현하는 업무가 늘어난다.

OpenID Connect의 과정이 간단하더라도 아직 제대로 지원되지 않고 있다.

### HMAC extends HTTP

    사용자의 정보가 누출되는 것이 걱정된다면, 다른 대안으로 OAuth 명세서 일부와 AWS의 S3 API에 의해서
    폭넓게 사용되는 해시 기반 메시징(HMAC)을 사용하는 것이다.

암호학에서 비밀 암호화 키와 암호화 하는 해쉬 함수를 포함한 HMAC은(가끔식 비약식적으로 키로 해쉬된 메시지 해쉬 기반 메시지 인증 코드 라고 불리움) 메시지 인증 코드의 명확한 종류중 하나이다.

HMAC는 데이터 무결성과 메시지의 인증하는 것을 입증하기 위해서 동시에 사용되고는 한다.

#### HMAC 과정
<img src="https://en.wikipedia.org/wiki/HMAC#/media/File:SHAhmac.svg">

_HMAC에서 요청 메시지는 비밀 키를 사용하여 해시되고, 해시 결과는 요청과 함께 전송됩니다. 그다음에는 서버가 자신이 가진 비밀 키의 복제본을 사용해 해시를 재생성하고 이들이 서로 일치한다면 서버는 그 요청을 수락합니다._

이렇게 된다면 중간에 변조를 시도해도 해쉬와 맞지 않아 변조되었다는 것을 알 수 있으며, 비밀 키는 절대로 통신에 넣어 전송하지 않으므로 통신상에서 누출될 수도 없습니다!

결과적으로는 트래픽이 더 쉽게 캐시되고, 해시를 생성하는 부하가 HTTPS 트래픽을 처리하는 것보다 더 낮다는 추가 이점도 존재합니다!


##### HMAC의 문제점

    물론 HMAC의 대한 문제점은 없지만, 사용하는 방법에 대해서 문제점이 있을 수 있다.
    해당 문제점은 다음과 같다.

1. 클라이언트와 서버 모두 어떤 방식으로 해서 기밀을 공유하는데, 공유하는 과정에서 양단간의 기밀을 하드코딩할 수 있지만 기밀이 누출된다면 접근을 타단하는 데 문제가 있다.

2. HMAC는 패턴이지 표준은 아니므로 다양한 구현 방법이 있는데, 이 방법에 대해 공개적이며 가용한 양질의 구현체가 부족하다.

3. 이 방식은 제 3자가 요청 내용을 조작하지 않았다는 것과 비밀 키 자체의 기밀성만을 보장한다!

### API키

    구글, 네이버, 카카오, 트위터, 페이스북, AWS와 같은 서비스의 공개된 API를 사용하기 위해서는 API 키라는 것을 발급받는다.
    왜 이 API키를 발급을 받는지? API 키의 장점?

API키를 통하여 서비스는 API 호출자를 인식할 수 있고 호출자의 대한 응답으로 제한을 둘 수 있다.

이 제한은 리소스 제한 뿐만 아니라, 속도 제한, 혹은 마이크로 제어가 가능하기 때문에 서비스 품질을 유지하는데 도움을 줄 수 있다.

API 키들은 일반적으로 공개 키와 개인 키를 짝으로 사용하며, 신원을 한 곳에서 제어하듯이키도 한 곳에서(게이트웨이..) 제어하여 관리한다.

#### 대리인 문제

    만약에 한 API를 호출한다고 해서, 내부 경계에 있는 모든 서비스 호출을 한다는 API가 있다고 하자.
    이것이 만약에 온라인 서비스 요청임을 확인하는 구조만 있다면 이상이 없을까?

이는 악의적인 서비스 이용자가 서비스 대 서비스 통신에서 사용할 수 있는 취약한 구조를 취하고 있다.

대리인 서비스를 속여 하위 서비스에 대한 인가되지 않은 호출을 하는 취약점의 한 형채인 [혼동된 대리인 문제다.](https://en.wikipedia.org/wiki/Confused_deputy_problem)


보관 중인 데이터를 보호하는 기법
--------------------------------

    많은 화제가 된 보안 침해 사건은 공격자가 탈취하는 보관 중인 데이터와 연관이 있다.
    이는 데이터가 암호화된 형태로 저장이 되지 않거나, 운영 체제에 침해할 수 없도록 막는 모든 조치를 여기서 다룬다.


### 유명한 암호 알고리즘을 사용해라

    데이터 암호화를 망치는 가장 쉬운 방법은 독자적인 암호화 알고리즘을 직접 구현하거나 심지어 다른 사람의 암호 알고리즘을 구현하는 것이다.

어떤 프로그래밍 언어를 사용하더라도 인정된 암호화 알고리즘의 구현체 중에서 검토를 거쳐 정기적으로 패치되는 것을 구해서 사용하라!

보안은 항상 트렌드를 따라가기 떄뭉네 취약점이 발견되었을 때 패치하고 최신 버전을 유지할 수 있도록 메일링이나 권고 리스트에 가입하라!

> 잘못 구현된 암호화가 주는 거짓된 안도감은 중요한것을 은폐하므로 차라리 없느니만 못하다.

### 키가 전부다

    지금까지 키를 이용해 보안을 강화하였는데, 그 키는 어디에 저장해야할까?

데이터를 암호화하고 복호화할 보안 장치를 분리하는 것이다.

다른 방법은 서버들이 키를 필요로 할 때 접근할 수 있는 분리된 키 금고를 이용하는 것이다!

물론, [MS에서 지원하는 암호화된 내장 데이터 베이스(TDE)들도](https://docs.microsoft.com/ko-kr/sql/relational-databases/security/encryption/transparent-data-encryption?view=sql-server-2017) 있다.

하지만, 가장 중요한 것은 키가 어떻게 처리되는지 조사하고, 막으려는 위협을 실제로 완화시키고 있는지 잘 이해하라.

### 암호화 대상 정하기

    A to Z 까지 모든것을 하나씩 보면서, 이건 암호화해야하고.. 저건 안해야하고..
    이렇기 보다는 모든 것을 암호화 시킨다면 저렇게 구별해야 하리 일이 없어 일이 수월해질 수 있다.
    하지만 문제 분석을 돕기 위해 어떤 데이터를 로그에 추가해야할지, 하드웨어 부하 등 여전히 고민해야 한다.

알고 있는 테이블 집합에만 암호화하는 것이 현명한 접근 방법이다.

### 요구형 복호화

    데이터를 처음 볼 때 그것을 암호화라. 데이터의 요청이 있을 때 복호화하고 복호화된 데이터는 어디에도 저장되지 않도록 하라.

백업 암호화

심층 방어

1. 방화벽
2. 로그
3.  IDS, IPS 구현
4. 망 분리
5. 운영 체제

필요어ㅗㅄ는 고객의 데이터를 저장하면, ㅎ무쳐각것도 없고, 굳이 저장할 필요가 없다.

데이터 최소화는 절대저긍로 요구되는 만큼의 정보만 저장하는 개념을 함추갛고 있음.

인적 요소
사회 공학 해킹의 관련된 이야기, 사람들에게 보안 윤리 의식을 심어주어야 한다.
ㅎ
보안 탑재 이야기 나옴

외부 검증
- 모의 해킹 이야기.


