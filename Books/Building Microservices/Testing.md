테스팅
---------

테스트의 종류
==============

    기존에 내가 생각하기에는 단위 테스트, 사용자 테스트, 성능 테스트, 서비스 테스트, 성능 테스트등 여러가지 테스트가 있다고만 생각했다.
    하지만, 이걸 추상화해서 크게 나누다면 인수 테스팅, 탐색 테스팅, 단위 테스팅, 속성 테스팅 이렇게 나뉜다.
    위에 내가 적은 테스트는 단위 테스팅과 속성 테스팅이 안에 있는 것들을 적은 것이다.

### 인수 테스팅
    인수 테스팅은 옳은 것을 빌드했는가?
    의사소통과 최대한 많은 경우의 수를 통하여 옳은 작업을 하는 프로그램을 빌드 하였는가? 에 대해서 물어보는 것이다.

### 탐색 테스팅
    탐색 테스팅은 어떻게 시스템에 장애를 만들 수 있을까?
    의도하지 않는 작업을 통해 장애가 발생하는지에 관한 내용을 물어보고 있다.

### 단위 테스팅
    단위 테스팅 은 제대로 빌드했는가?
    이것은 자동 배포에 관한 내용인데 혹시라도 자동 배포에 몇 가지 멱등성을 무시하고 다른 과정이 포함되는것을 방지하기 위한 테스트이다.

### 속성 테스팅
    속성 테스팅 같은 경우에는 응답 시간, 확장성, 성능, 보안 관련되있음.
    성능 테스트와 연관되어 있다.

> 프로그래머들이 신경써야하는 단위 테스팅의 중점을 두고 설명할 것이다.

테스트 피라미드
===============
<img src="https://martinfowler.com/bliki/images/testPyramid/test-pyramid.png">

[_This Image had Copyright by Martin Fowler_](https://martinfowler.com/bliki/TestPyramid.html)

    피라미드 처럼 맨 위는 UI 테스트 그 밑은 서비스 테스트 그 밑은 유닛 테스트로 분리되었으며
    피라미드 위쪽으로 올라갈수록 테스트의 범위가 넓어지고, 그로인해 실행속도도 느려지지만
    피라미드 아래쪽으로 내려갈수록 테스트의 범위가 작아지고, 실행속도는 빨라진다.

### 유닛 테스트

#### 유닛 테스트의 크기

    "코드 한 줄을 가지고 있는 함수를 테스트 하는 것도 유닛 테스트인가요?" 라면 정답부터 말하자면 맞습니다.
    코드 한 줄도 일종의 한 유닛이기 때문이죠. 헌데, 여러 함수와 클래스를 테스트 하는 것은 유닛 테스트가 아닙니다.
    여러 유닛이 겹쳐있기 때문이죠.

#### 유닛 테스트의 목적

    TDD(Test Driven Development)는 테스트 주도 개발로 테스트를 먼저 작성한 후 개발을 하는 것이고
    TDD는 유닛 테스트를 낳았습니다.

유닛 테스트의 목표는 기술 중심이며, 끊임없이 테스트하고 리팩토링한다. 라는 주제로 개발을 합니다.
리팩토링을 중심적으로 생각하는 사람이 많은데 앞서 말했듯이 **유닛 테스트의 목적은 정상적으로 동작하는지 확인하는 것입니다.**


### 서비스 테스트

    서비스 테스트는 유닛보다 더 큰 서비스 단위이며, 이 서비스를 중점적으로 테스트하는 것을 서비스 테스트라고 한다.
    서비스 테스트는 서비스 하나만 테스트 하기 때문에, 다른 서비스들과 교류하는것은 모두 Dummy로 만든 후 테스트를 진행한다

#### Mock과 Stub

##### 스텁

    스텁은 함수 자체를 원하는 결과로 바꿀 수 있는 것

EX) 카드 결제 서비스를 이용하고 있는데, 이 서비스는 포인트 적립 서비스로 해당 카드의 결제 금액을 보내고 포인트 적립 서비스는 5% 캐쉬백을 저장했다는 메시지를 반환한다. 카드 결제 서비스를 테스트 한다고 가정했을 때, 포인트 적립 서비스로 받는 응답은 Stub화 하여 포인트 적립 프로세스 없이 저장했다는 메시지만 받도록 할 수 있다.

##### 목

    목은 함수 호출의 수행까지 보장하여 함수가 중복 실행되거나 혹은
    우리의 예상과 맞지 않도록 동작 했을 때 부작용을 발생하는지 확인하는데 매우 유용하다.

EX) [쉽게 설명한 예제 포스트](https://medium.com/@SlackBeck/mock-object%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-85159754b2ac)

##### 퓨~전!

    스텁과 목, 이 두 개를 사용하는 것은 더블 테스트라고 불린다.

Fake, Spy, Dummy..등 용어를 사용한다면 개발자 사이에서는 혼동이 있을 수 있다.
물론, 이 두개를 잘 구별하는 훌륭한 개발자 분들도 많겠지만. 나는 혼동이 있을 여지는 쳐내는게 좋다고 생각한다.


### 종단 테스트

    전부 하나부터 끝까지, 켠김에 왕까지, 테스트 하는김에 전체 테스트까지.
    테스트의 끝판왕인 종단 테스트다.

_위에서는 UI 테스트라고 했지만 End-To-End으로 진행되니까 종단 테스트라고 표현하겠습니다._

앞서 말했듯이 유닛들을 모은 서비스를 전부 모아 전체 서비스를 테스트하는 것이다.

**모든 서비스를 테스트하는 종단 테스트에서는 많은 문제점들이 존재한다.**

1. 이 종단간 테스트 같은 경우에는 서비스를 전체 테스트하기 때문에 외부의 요인도 신경써야한다.
2. 테스트의 범위도 넓어져서 관리하기 힘들 수 있다.
3. 테스트가 실패 하였을 때 어느 서비스가 문제인지 알기기 힘들다.

그래서 이 단점을 보안한 소비자 주도 테스트가 있다.

### 소비자 주도 테스트

    소비자 주도 계약을 하여 소비자와 서비스를 관리하는 관리자와 짝을 맺어 일부 서비스에 대해 연결되는 부분은 스텁화하고 작업을 한다.
    여기서 발생하는 행동 양식은 코드화해서 작업을 하는 것이며, 엔드 투 엔드 테스트의 엑기스만 뽑아놓은 것이다!

소비자가 하는 모든 행동을 양식으로 만들어 테스트 하는것은 테스트만으로도 서비스의 테스팅은 끝낼 수 있다.

> 그렇다면 결국엔 종단 테스트는 할 필요가 없는 테스트인가?

### 종단 테스트만의 이점

    종단 테스트를 사용해서 얻을 수 이점이 더 큰 경우에는 종단 테스트를 사용할 수 있다!
    이점은 다음과 같다.

1. 실환경 시스템을 모니터링 하기 위해 유의적 모니터링이 필요한데, 이 것은 더 많은 종단 테스트를 사용한다.

2. 실환경 배포 전에 보조 수단으로 종단 테스트를 실행하는 것을 있다.

3. 종단 테스트는 감소된 위험과 순환 시간간의 균형을 유지할 유용한 안전망 처럼 형성할 수 있다.

4. 모든 결함의 원인을 제거하고 실환경에서 적절한 처리와 효과적인 모니터링이 여전히 필요하다는 것을 이해하는 한 종단 테스트는 합리적이 선택이다.

> 물론, 테스트에서 극복할 수 없는 내용이 담겨있기 때문에 릴리즈에서 발견되는 버그를 해결하기 위한 여러가지 테스팅 기법도 존재한다.

테스트의 파이프라인
===================

지금까지 유닛테스트도 존재, 서비스를 기준으로 테스트하는 서비스 테스트, 소비자의 행동 패턴을 코드로 구현한 소비자 주도 테스트, 마지막으로 전체를 테스트하는 종단 테스트가 존재(End-to-end)한다.

그래서 항상 규격화 되었던 테스트 파이프라인을 굳이 사용자의 환경과 맞지 않는다고 해도 불구하고 사용할 필요는 없다.

> 서비스 환경에 따라 필요한게 무엇인지 그것이 과연 꼭 필요한 테스트인지 결정하고 이행해야만 한다.

릴리즈 후 버그 고치기
===================

> 테스트에서는 '극복할 수 없는 내용이 아닌 테스트보다 실환경에서 발견되는 버그가 더 유익할 수 있다.' 라는 말이 존재하며 평균 무고장 시간 [MTBF](https://ko.wikipedia.org/wiki/%ED%8F%89%EA%B7%A0_%EB%AC%B4%EA%B3%A0%EC%9E%A5_%EC%8B%9C%EA%B0%84), [MTTR](https://en.wikipedia.org/wiki/Mean_time_to_repair) 사이의 최적화에 대한 균형으로 언급된다.

### 스모크 테스트

<img src="https://blog.gesrepair.com/wp-content/uploads/2017/01/smoked-board.jpg">
_레지스터가 불에 탄 회로_

    회로판을 만들어서 전력을 공급해서 전원을 키니 연기가 나온다. 당장 그 상태로 시중에 나오면 어떨까?

왜 스모크 테스트라고 이름을 지었냐면, 회로판에 전력을 넣고 전원을 켰을때 **연기가 나지 않고 동작하는지의** 어원으로

릴리즈할 소프트웨어를 거부할 만큼 심각한 장애가 있는지 확인하는 예비 테스트로, 컴포넌트나 시스템의 가장 중요한 기능이 동작하는지에 중점을 둔 것이다.

### 블루/그린 배포

<img src="https://cdn2.hubspot.net/hubfs/208250/Blog_Images/bluegreen1.png">
_한눈에 알 수 있는 블루/그린 배포 시스템_

개발한 서비스를 실환경에 완전히 릴리즈 하기 전에 일부 서비스만 조금씩 개발한 서비스에 접근하도록 하고 나머지는 기존 서비스로 접근하게 만든다.

만약 개발한 서비스에서 문제가 생긴다면, 기존 서비스로 다시 되돌리면 된다!

### 카나리아 테스트

    블루/그린과 굉장히 비슷한 테스트인데, 1%의 서버만 해당 서비스 운영.. 5% 서버만 운영.. 15%.. 30%.. 60%.. 100%
    시간이 지날수록 다른 서버에 점진적으로 배포하는것이다!
