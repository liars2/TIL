리눅스 프로그래밍
=================

    시스템의 하위레벨과 동떨어진 상위 레벨에서 동작하는 애플리케이션일지라도 시스템 프로그래밍을 알고 개발한다면 더 나은 애플리케이션을 만들 수 있다.
    시스템 내부에 대한 이해는 모든형태의 프로그래밍에 있어 큰 도움이 되기 때문이다.

시스템 프로그래밍
-------------------

    커널 및 핵심 시스템 라이브러리를 직접 사용하면서 하위 레벨에서 동작하는 시스템 소프트웨어를 작성하는 기술

셸, 텍스트 편집기, 컴파일러, 디버거, 시스템 유틸리티 및 시스템 데몬은

**시스템 라이브러리를 사용하면서 하위 레벨에 동작하므로 시스템 소프트웨어의 종류이다.**

전통적으로는 모든 유닉스 프로그래밍은 시시스템 프로그래밍이라고 할 수 있다.

유닉스 프로그래밍을 돌이켜보면 추상화가 잘 된 프로그래밍은 아니였다.

유닉스에서 프로그래밍을 한다고 하였을 때 실제 유닉스의 API를 호출 할 수 있었기 때문에 추상화가 잘 되지 않았다고 표현할 수 있다.

### 시스템 프로그래밍과 애플리케이션 프로그래밍의 차이

시스템 프로그래밍은 머신이 돌아가는 운영체제와 하드웨어를 정확히 알아야 하며 주로 커널 및 시스템 라이브러리를 사용한다.

하지만 애플리케이션 프로그래밍 같은 경우엔 시스템 프로그램과 달리 추상화된 고급 **라이브러리를** 사용한다

#### 고급 라이브러리

    하드웨어나 운영체제를 추상화 하는데, 추상화를 통하여 운영체제와 하드웨어를 정확히 알지 못해도 되며,
    각기 다른 운영체제와 하드웨어 간의 호환성을 가져다 주며 강력한 상위 레벨의 툴킷을 작성할 수 있게 해준다.

> 그래서 애플리케이션을 작성할 때 고급 라이브러리나 시스템라이브러리를 얼마나 사용할지는 전적으로 애플리케이션이 동작하는 범위에 따라 결정된다.

리눅스 시스템 프로그래밍의 3가지 구성 요소
-----------------------------------

### 시스템 콜

    시스템 프로그래밍은 시스템 콜에서 시작해 시스템 콜로 끝난다.
    시스템 콜은 운영체제에 리소스나 서비스를 요청하려고 사용자 영역에서 시작해 커널 내부로 들어가는 함수 호출이다.

read, write, get_narea, set_tid_address와 같은 함수까지 그 범위가 다양하다.

#### 시스템 콜 호출하기

    사용자 영역의 애플리케이션에서 커널 영역으로 집적 연결하는 것은 불가능하다.
    보안과 안정성의 이유로 애플리케이션은 커널 코드를 직접 실행하거나 커널 내부 데이터를 조작할 수 없다.

하지만, 애플리케이션이 시스템 콜을 실행하려 한다는 '시그널'을 커널로 보낼 수 있다.

<img src="http://www.padakuu.com/articles/images/cover/cover-170831075003.png">

_애플리케이션에서 커널에게 리소스를 요청하는 과정을 추상적으로 표현한 것_

ex) i386에서는 애플리케이션에서 [소프트웨어 인터럽트 명령인 int에](https://ko.wikipedia.org/wiki/INT_(x86_%EB%AA%85%EB%A0%B9%EC%96%B4)) 0x80이라는 값을 넘기면 보호된 커널 영역으로 들어가 소프트웨어 인터럽트 핸들러를 실행한다.

애플리케이션은 실행할 시스템 콜과 매개 변수를 레지스터를 통해 전달한다.

시스템 콜은 0부터 시작하는 16진수로 나타내며 시스템 콜을 호출하려면 레지스터에 해당 시스템 콜을 먼저 저장해야한다.

ex) i386 아키텍쳐에서 [시스템 콜 5 번인 open](http://asm.sourceforge.net/syscall.html#5)을 호출하려면 응용 프로그램은 int 명령을 실행하기 전에 eax 레지스터에 5를 저장해야한다.

매개 변수 전달도 비슷한 방식으로 처리되는데 i386에서는 ebx, ecx, edx, esi, edi 레지스터에 순서대로 다섯 개의 매개 변수를 저장한다.

만약에 매개 변수가 다섯 개 이상 필요할 때는 레지스터 하나에 나머지 모든 매개 변수를 담은 사용자 영역의 버퍼를 가리키도록 한다.

아키텍처별로 시스템 콜을 처리하는 방식은 다르지만, 기본 원리는 같다.

### C 라이브러리

    C 라이브러리(libc)는 유닉스 애플리케이션의 핵심이다. 심지어 다른 언어로 프로그래밍해도 상위 레벨의 라이브러리에 포함되어
    핵심 서비스와 시스템 콜을 처리하기 위해 C 라이브러리가 동작한다.

GNU C 라이브러리는 C 라이브러리뿐만 아니라 시스템 콜에 대한 래퍼와 스레드 지원, 그리고 기본 애플리케이션 기능에 대한 내용도 포함하고 있다.

### C 컴파일러

    리눅스는 표준 C 컴파일러로 GNU 컴파일러 컬렉션(GCC)을 제공한다.
    GNU C Compiler 였지만, 여러가지 언어를 지원하게 되어 일반적인 이름으로 알려지고 있다.

API와 ABI
-------------------

### Application Programming Interface

    API는 소프트웨어의 소스 코드 레벨에서 서로 인터페이스 하는 방식을 정의한다.
    일반적으로 API의 표준 인터페이스는 함수이며 상위 레벨의 소프트웨어에서 더 하위 레벨의 소프트웨어를 호출할 수 있다.

원하는 동작을 제공하는 집합을 API라고 부를 수 있으며, API는 인터페이스일 뿐이며 그 인터페이스를 사용하여 구현한 소프트웨어를 API 구현체라고 한다.

API의 사용자는 API와 그 구현에 직접적인 영향을 끼치지 못한다.

API 그 자체를 사용하거나 하지 않거나 둘 중 하나이다.

즉, API의 구현체와 관계없이 그 API를 따르기만 한다면 성공적으로 컴파일된다.

### Application Binary Interface

    ABI는 애플리케이션 내에서의 상호 동작, 커널과 애플리케이션,
    혹은 애플리케이션과 라이브러리 간의 상호 동작에 대해서 정의한다.

API가 소스 코드 수준의 호환성을 보장한다면, ABI는 바이너리의 호환성을 보장하며 이는 [오브젝트 코드를](http://www.terms.co.kr/sourcecode.htm) 다시 컴파일하는 수고 없이 같은 ABI를 지원하는 시스템이라면 동일한 기능을 수행하도록 보장한다.

ABI는 [콜링 컨벤션](https://ko.wikipedia.org/wiki/%ED%98%B8%EC%B6%9C_%EA%B7%9C%EC%95%BD), [바이트 순서](https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8), 레지스터 활용, 시스템 콜 실행, 라이브러리 링크, 라이브러리 동작 방식, 바이너리 오브젝트 형식과 같은 내용과 관련이 있다.

ABI 대부분은 특정 레지스터나 어셈블리 명령어 같은 하드웨어에 국한된 개념을 다루고 있다.

표준
------------

    유닉스 프로그래밍의 기초는 지난 수십 년간 크게 바뀌지 않았다./
