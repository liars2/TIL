캐시
==========
    웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다.
    웹 요청이 캐시에 도착했을 때, 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다.

불 필요한 데이터 전송
--------------
    복수의 클라이언트가 자주 쓰이는 원 서버에 페이지에 접근할 때,
    서버는 같은 문서를 클라이언트에게 각각 한 번씩 전송하게 된다.
> 캐시를 이용하면, 첫 번째 응답은 캐시에 보관되고 캐시된 사본이 뒤 이어 사용될 수 있기에 중복해서 트래픽을 주고받는 낭비가 줄어드게 된다.

대역폭 병목
--------------
    캐시는 또한 네트워크 병목을 줄여준다 많은 네트워크가 원격 서버보다
    로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.

요청 쇄도
-------
    캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
    갑작스런 사건(뉴스 속보, 유명 인사와 관련된 사건)으로 인해 많은 사람이 접근할 때 이런 일이 발생한다.

거리로 인한 지연
------------
    비역 대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있다.
    모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.

적중과 부적중
----------
    캐시는 유용하긴 하지만, 모든 문서의 사본을 저장하지는 않는다.
**캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다.**

> 이것을 캐시 적중이라고 부른다, 만약 사본이 없다면 원 서버로 전달되기만 할 뿐이다. *이것을 캐시 부적중이라고 부른다.*

재검사
----
    원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 그들이 갖고 있는 사본이
    여전히 최신인지 서버를 통해 때떄로 점검해야 한다.

> 이러한 **신선도 검사를 '재검사'라고 부른다.**
캐시는 원한다면 스스로 사본을 재검사할 수 있지만, 수백만개씩 가지고 있는 경우가 흔한데 비해</br>
네트워크 대역폭은 부족하기 때문에, 대부분의 캐시는 클라이언트가 사본을 요청하였으며</br>
그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재 검사를 한다.

### 재검사 적중
사바 객체가 변경되었다면, 서버는 콘텐츠 전체와 함께 평범한 `HTTP 200 OK` 응답을 클라이언트에게 보낸다.
서버 객체가 변경되지 않았다면 `304 Not Modified` 응답을 보내고 
> 신선도 검사를 해서 여전히 신선하다면 캐시 객체를 주고, 신선하지 않다면 서버 객체를 준다.

#### 갹체 삭제
    만약 서버 객체가 삭제되었다면, 서버는 `404 Not Found` 응답을 돌려보내며, 캐시 사본을 삭제한다.

### 적중률
    캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 한다.
    적중률은 0에서 1까지의 값으로 되어 있지만, 흔히 퍼센트로도 표현되기 한다.
> 0%는 캐시 부적중, 그리고 100%는 모든 요청이 캐시 적중임을 의미한다.

### 바이트 적중률
    문서들이 모두 같은 크기인 것은 아니지만 문서 적중률이 모든 것을 말해주지는 않는다.
    몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다.
> 이런 이유는, 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다.

바이트 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
이 측정값은 트래픽이 절감된 정도를 포착해낸다.

> 문서 적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표다.

### 적중과 부적중의 구별
    불행이도, HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.
    두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 200 OK가 될 것이다.
    어떤 상용 프락시 캐시는 캐시에 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가 정보를 붙인다.
> Date 헤더를 이용하여 캐시된 것을 알거나, Age 헤더를 이용하여 알 수 있다.

캐시 토폴로지
---------
캐시는 한 명의 사용자에게만 할당될 수도 있고 반대로 수천 명의 사용자들 간에 공유될 수도 있다.

> 개인 한 명에게만 할당된 캐시를 개인 전용 캐시라 부르고, 공유된 캐시는 공용 캐시라고 불러 사용자 집단에게 자주 쓰이는 페이지를 담는다.

### 개인 전용 캐시
    개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있다.
    웹 브라우저를 통한 디스크, 메모리에 캐시해 놓고 설정 및 수정할 수 있도록 허용한다.
> 개인이 사용하기 때문에, 서버에 대하여 제각각 접근한다.

### 공용 프락시 캐시
    공용 캐시는 캐시 프락시 서버 혹은 더 흔히 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다.
> 여러 사용자가 접근하기 때문에, 불 필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

### 프락시 캐시 계층들
    작은 캐시에서 부적중이 발생했을 때, 더 큰 캐시가 그 '걸러 남겨진' 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다.
<img src="../Image/Accessing documents in a two-level cache hierarchy.png">

하지만, 캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 될 것이다.</br>
**프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생할 것이다.**

### 캐시망, 콘텐츠 라우팅, 피어링
    몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.
    캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지,
    아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지 대한 결정을 동적으로 내린다.

캐시 처리 단계
-----------
### 단계 1: 요청 받기
    캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어드린다.
### 단계 2: 파싱
    캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.
### 단계 3: 검색
    단계 3에서, 캐시는 URI를 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다.

> 로컬 복사본은 메모리, 디스크나 다른 컴퓨터에 저장되있을 수도 있다.
**전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용한다.**

### 단계 4: 신선도 검사
    HTTP는 캐시가 일정 기간 동안 사본을 보유할 수 있도록 해준다.
    이 기간동안, 문서는 '신선'한 것으로 간주되고 캐시는 서버와의 접촉 없이 이 문서를 제공할 수 있다.
> 신선도 한계를 넘을 정도로 오래 갖고 있었다면 그 갹체는 '신선하지 않는' 것으로 간주되며,</br>캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야한다.

### 단계 5: 응답 생성
    캐시된 응답을 원 서버에서 온 것처럼 보이게 하고 싶기 때문에,
    캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다.

> 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다.

**캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있다.**

### 단계 6: 전송
    일단 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다.
    모든 프락시서버들과 마찬가지로, 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있다.
> 고 성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다.

### 단계 7: 로깅
    대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다.
    각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고
    로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지를 알려주는 항목을 추가한다.
- 페이지ㄹ 가까운 곳으로 거리지연