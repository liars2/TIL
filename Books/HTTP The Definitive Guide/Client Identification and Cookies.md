클라이언트 식별과 쿠기
========================
    서버가 통신하는 대상을 식별하는 데 사용하는 기술들인 CL 식별과, 쿠키의 종류를 설명하고
    과거부터 지금까지 사용되는 사용자 식별 기술을 논의한다.

기존에 사용되었던 클라이언트 식별 기법
--------------------------------------

### HTTP 헤더

| 헤더 이름       | 헤더 타입  | 설명                                     |
|-----------------|------------|------------------------------------------|
| From            | 요청       | 사용자의 이메일 주소                     |
| User-Agent      | 요청       | 사용자의 브라우저                        |
| Referer         | 요청       | 사용자가 현재 링크를 타고 온 근원 페이지 |
| Authorization   | 요청       | 사용자 이름과 비밀번호                   |
| Client-ip       | 확장(요청) | 클라이언트 IP 주소                       |
| X-Forwarded-For | 확장(요청) | 클라이언트 IP 주소                       |
| Cookie          | 확장(요청) | 서버가 생성한 ID 라벨                    |

##### From
    From 헤더로 사용자를 식별 가능하다 하지만 대부분 로봇으로 데이터을 수집하는 과정에서
    문제를 일으켰을 때, 해당 사이트의 웹 마스터가 항의 메일을 보낼 수 있도록 기술
##### Referer
    사용자가 페이지로 유입하기 전 페이지에 대한 정보가 있어, 사용자의 취향을 더 잘 파악할 수 있다.

**From, Referer 같은 헤더들은 확실히 식별하기에는 부족한 정보를 가지고 있다. 더 정확한 방법에 대해 알아보자.**

### 클라이언트 IP 주소

    초기 웹 선구자는 사용자들의 클라이언트 IP주소를 사용하려고 했다.
    주소가 바뀌지 않고, 요청마다 클라이언트의 IP를 알 수 있다면 문제없이 동작했기 때문이다.
> 하지만, 클라이언트 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점을 가진다.

- 클라이언트 IP는 사용하는 컴퓨터를 가르킨다. 만약 여러 사람이 그 컴퓨터를 사용한다면 식별할 수 없다.
- 많은 ISP는 로그인하면 동적으로 IP 주소를 할당, 사용자는 매번 다른 주소를 받음.
- 보안 강화에 이유로 NAT 방화벽 설치로 인한 IP 변환
- 웹서버는 클라이언트에 IP 주소 대신 프락시 서버 IP를 봄, 물론 Client-ip 혹은 X-Forwarded-For HTTP 같은 것도 있지만.<br>**모든 프락시가 지원하지 않는다.**

### 사용자 로그인
    웹 서버는 사용자 이름과 비밀번호로 인증 할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
    로그인이 더 쉽도록 WWW-Authenticate, Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.

```text
하지만 웹 사이트 로그인은 귀찮은 일이다. 사이트를 이동할 때마다 일일히 로그인을 해야 하고
서로 다른 아이디 및 비밀번호 정책 때문에 사용자들을 질려한다.
```
> 이것을 해결하기 위해 뚱뚱한 URL을 사용한다

### 뚱뚱한 URL
    어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별, 추적하였다.
    URL의 처음이나 끝에 상태 정보를 추가해 확장하는 URL
> 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL 이라고 부른다.

웹 서버와 독립적인 HTTP 트랜젝션을 하나의 '세션' 혹은 '방문'으로 묶는 용도로 뚱뚱한 URL을 사용할 수도 있다.

``` 사용자가 웹 사이트에 처음 방문하면, 유일한 ID가 생성되고 그 값은 서버가 인식할 수 방식으로 URL에 추가 된다.```

**하지만 이 기술에도 여러 심각한 문제가 존재한다.**

- 못생긴 URL<br>
    뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.

- 공유하지 못하는 URL<br>
    뚱뚱한 URL은 특정 사용자와 세션에 대한 상태 정보를 포함하는데<br>만약 그 주소를 공유한다면 누적된 개인 정보를 본의 아니게 공유하게 되는 것이다.

- 캐시를 사용할 수 없음<br>
    URL로 만드는 것은, URL이 달라지기 때문에 기존 캐시에 접근할 수 없다는 것을 의미한다.

- 서버 부하 가중<br>
    서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 한다.

- 이탈<br>
    사용자가 만약 다른 사이트로 이탈 후 재 접속을 한다면 지금까지의 진척사항들이 초기화되며 다시 처음부터 시작해야 할 것이다.

- 세션 간 지속정의 부재<br>
    사용자가 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

쿠키
----
### 쿠키란?
    사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
    넷스케이프가 최초로 개발했지만, 지금은 모든 브라우저에서 지원한다.

#### 쿠키의 타입
    쿠키는 크게 두가지로 나누어진다.
- 세션 쿠기<br>
    사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키

- 지속 쿠기<br>
    디스크에 저장되어 남아있으며 주기적으로 방문하는 사이트의 설정 정보, 로그인 이름을 유지.

**세션 쿠키와 지속 쿠키의 다른 점은 파기되는 시점뿐이다.**

### 쿠키 동작 방식
    쿠키는 서버가 사용자에게 "안녕, 내 이름은.."라고 적어서 붙이는 스티커와 같다.
    사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙인 모든 스티커를 읽을 수 있다.

쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 같은 Set-Cookie2 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.

### 사이트 마다 각기 다른 쿠키들
브라우저는 수백개의 쿠키를 가지고 있을 수 있지만, 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다. 이유는 다음과 같다.

- 쿠키를 모두 전달하면 성능이 크게 저하된다.

- 이 쿠키들은 대부분 서버에 특화돤 이름/값 쌍을 포함하고 있기 때문에, 대부분 사이트에서는 인식하지 않는 무의마한 값이다.

- 모든 사이트에 쿠키 전체를 전달하는 것은, 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 잠재적인 개인정보 문제를 일으킬 것이다.

### 쿠키와 세션 추적
    쿠키는 웹 사이트에수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.
    전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 쇼핑카트를 유지하려 세션 쿠키를 사용한다.

<img src='../Image/Amazon_tracking_way.png'>
위 그림은 Amazon.com 에 들어가면 일어나는 트랜젝션들의 연속을 보여준다.

    (a) Amazon.com 에 루트페이지 요청
    (b) 클라이언트를 전자상거래 사이트로 redirect
    (c) 클라이언트는 리다이렉트 URL로 요청
    (d) 쿠키 두개를 기술 후 다른 URL로 리다이렉트
    (e) 클라이언트는 새로운 URL을 요청을 앞서 받은 두 개의 쿠키와 함께 보냄
    (f) 서버는 home.html 페이지를 가져오고 총 4개의 쿠키를 전달
    (g) 서버는 콘텐츠 전달

### 쿠키와 캐싱
    쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.
    이전 사용자의 쿠키가 다른 사용자에게 할당돼버리거나,
    개인정보가 다른이에게 노출되는 최악의 상황이 일어날 수도 있다.
> 쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않다.<br>다음은 캐시를 다루는 기본 원칙에 대한 안내다.

##### 캐시되지 말아야 할 문서가 있다면 표시하라
    만약 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면
    명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술해서 명확히 표시한다.

##### Set-Cookie 헤더를 캐시 하는 것에 유의하라
    만약 응답이 Set-Cookie 헤더를 가지고 있드면, 본문은 캐시할 수 있지만
    Set-Cookie 헤더를 캐시하는 것은 주의해야 한다.

> 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패할 것이기 때문이다.

##### Cookie 헤더를 가지고 있는 요청을 주의하라
    요청이 Cookie 헤더와 같이 오면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다.
    개인정보는 캐시되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다.

### 쿠키, 보안 그리고 개인정보
    쿠키를 사용하지 않도록 비활성화 시킬 수 있고
    로그 분석과 같은 다른 방법으로 대체하는 것도 가능하므로
    그 자체가 보안상으로 엄청나게 위험한 것은 아니다.

**개인정보를 다루거나 사용자를 추적하는 기술은 잘못된 의도로 사용될 수 있기 때문에 항상 조심하는 것이 좋다.**

**가장 큰 오용 중 하나는**
> 협력업체 웹 사이트가 사용자를 추적하려고 지속 쿠키를 사용하는 것이다.

이것을 IP 주소와 Referer 헤더에 있는 정보와 함께 사용하면, 마케팅 회사들은사용자의 프로필과 사용 패턴에 대해 꽤 정확한 데이터를 수집할 수 있다.