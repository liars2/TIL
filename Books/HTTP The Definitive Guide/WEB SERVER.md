웹 서버
===================


다채로운 웹 서버
---------------------
    웹 서버는 HTTP 요청을 처리하고 응답을 제공한다
    '웹 서버'라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 가리킨다.

### 웹 서버 구현
    웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.
    자신이 제공하는 리소스를 관리하고 웹 서버를 설정, 통제, 확장하기 위한 관리 기능을 제공한다.

> HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리기능을 제공한다.

### 웹 서버가 하는 일

1. 커넥션을 맺는다
    <br>**클라이언트 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다**
2. 요청을 받는다
    <br>**HTTP 요청 메시지를 네트워크로부터 읽어 들인다.**
3. 요청을 처리한다
    <br>**요청 메시지를 해석하고 행동을 취한다.**
4. 리소스에 접근한다
    <br>**메시지에서 지정한 리소스에 접근한다**
5. 응답을 만든다
    <br>**올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다**
6. 응답을 보낸다
    <br>**응답을 클라이언트에게 돌려준다**
7. 트랜잭션을 로그로 남긴다
    <br>**로그파일에 트랜잭션 완료에 대한 기록을 남긴다.**

### 1단계: 커넥션을 맺는다.
    클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면,
    클라이언트는 요청을 보내기 위해 그 커넥션을 사용할 수 있다.
    그렇지 않다면, 클라이언트는 서버에 대한 새 커넥션을 열 필요가 있다.

#### 새 커넥션 다루기
    클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고
    TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다.
> 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.</br>**어떤 서버들은 클라이언트의 IP 주소나 호스트 명이 인가되지 않았거나 악의적이라고 알려진것인 경우 커넥션을 닫는다.**

### 2단계: 요청 메시지 수신
    커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메시지를 구성한다.

#### 요청 메시지를 파싱할 때 하는 일

- 요청줄을 파싱하여 메서드, 지정된 리소스의 식별자, 버전 정보를 찾는다
- 메시지 헤더들을 읽는다. 각 메시지 헤더는 CRLF로 끝난다.
- 헤더의 끝을 의미하는 CRLF로 끝나느 ㄴ빈 줄을 찾아낸다. (존재한다면)
- 요청 본문이 있다면, 읽어 들인다 (Content-Length 헤더로 정의 된다)

> 요청 메시지를 파싱할 때, 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받는다.

#### 커넥션 입력/출력 처리 아키텍쳐
    고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.
    이 커넥션들은 웹 서버가 전 세계의 클라이언트와 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 해준다.

<img src="../Image/Web server input, output architectures.png">

1. 단일 스레드 웹 서버
    ```text
    단일 스레드 웹 서버는 한 번에 하나씩 요청을 처리한다, 트랜잭션이 완료되면, 다음 커넥션이 처리된다.
    이 아키텍처는 구현하기 간단하지만 처리 도중에 모든 다른 커넥션은 무시된다.
    ```

2. 멀티프로세스와 멀티스레드 웹 서버
    ```text
    멀티프로세스와 멀티스레드 웹 서버는 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당한다.
    스레드/프로세스는 필요할 때마다 만들어질 수 있고 미리 만들어질 수 있다.
    몇몇 서버는 매 커넥션마다 스레드/프로세스 하나를 할당하지만, 서버가 수백, 수천, 심지어 수만 개의 동시 커넥션을 처리할 때
    그로 인해 만들어진 수많은 프로세스나 스레드는 너무 많은 메모리나 시스템 리소스를 소비한다.
    ```
3. 다중 I/O 아키텍쳐
    ```text
    대량의 커넥션을 지원하기 위해, 많은 웹 서버는 다중 아키텍처를 채택했다.
    다중 아키텍처에서는, 모든 커넥션은 동시에 그 활동을 감시당한다.
    커넥션의 상태가 바뀌면(예: 데이터를 사용할 수 있게 되거나 에러 발생), 그 커넥션에 대해 작은 양의 처리가 수행된다.
    그 처리가 완료되면, 커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다.
    ```
4. 다중 멀티 스레드 웹 서버
    ```text
    몇몇 시스템은 자신의 컴퓨터 플랫폼에 올라와 있는 CPU 여러 개의 이점을 살리기 위해 멀티스레딩과 다중화를 결합한다.
    여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다
    ```

### 3단계: 요청 처리
    웹 서버가 요청을 받으면, 메서드, 리소스, 헤더, 본문을 얻어 처리함
    POST를 비롯한 몇몇 메서드는 요청 메시지에 엔티티 본문이 있을 것을 요구한다.

### 4단계: 리소스의 매핑과 접근
    웹 서버는 리소스 서버다 그들은 HTML, JPEG 이미지 같은 미리 만들어진 콘텐츠를 제공하며,
    마찬가지로 서버 위에서 동작하는 리소스 생성 애플리케이션을 통해 만들어진 동적 콘텐츠도 제공한다.

> 웹 서버가 전달하려면, URI에 대응하는 콘텐츠나 콘텐츠 생성기를 찾아서 원천을 식별해야한다.

#### Docroot
    웹 서버는 여러 종류의 리소스 매핑을 지원한다.  
    하지만 리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다.
    일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약 해 둔다.

#### 디렉터리 목록
    웹 서버는, 경로가 파일이 아닌 디렉터리를 가리키는, 디렉터리 URL에 대한 요청을 받을 수 있다.
    대부분의 웹 서버는 클라이언트가 디렉터리 URL을 요청했을 때 다음과 같이 몇 가지 다른 행동을 취하도록 설정할 수 있다.

- 에러를 반환한다
- 디렉터리 대신 특별한 *색인 파일*을 반환한다.
- 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다.

#### 동적 콘텐츠 매핑
    웹 서버는 URI를 동적 리소스에 매핑할 수 있다.
    즉, 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑하는 것이다.

#### 서버사이드 인클루드(Server-Side Includes, SSI)
    많은 웹 서버가 서버사이드 인클루드도 지원한다. 
    만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 보내기 전에 처리한다.

#### 접근 제어
    웹 서버는 또한 각각의 리소스에 접근 제어를 할당할 수 있다.
    접근 제어되는 리소스에 대한 요청이 도착했을 때 웹 서버는 클라이언트의 IP 주소에 근거하여 접근을 제어할 수 있고
    혹은 리소스에 접근하기 위한 비밀번호를 물어볼 수 있다.

### 5단계: 응답 만들기
    한번 서버가 리소스를 식별하면, 서버는 요청 메서드로 서술되는 동작을 수행한 뒤 응답 메시지를 반호나한다.
    응답 메시지는 응답 상태 코드, 응답 헤더, 그리고 응답 본문을 포함한다.

#### 응답 엔티티
    트랜잭션이 응답 본문을 생성한다면, 그 내용을 응답 메시지와 함께 돌려보낸다.
    만약 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.

- 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
- 응답 본문의 길이를 서술하는 Content-Length 헤더
- 실제 응답 본문의 내용

#### 리다이렉션
    웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다.
    웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.
    리다이렉션 응답은 3XX 상태 코드로 지칭된다.

> 리 다이렉트는 다음의 경우의 유용하다
- 영구히 리소스가 옮겨진 경우
- 임시로 리소스가 옮겨진 경우
- URL 증강
- 부하 균형
- 친밀한 다른 서버가 있을 때
- 디렉터리 이름 정규화

### 6단계: 응답 보낸다
    웹 서버는 받을 때와 마찬가지로 커넥션 너머로 데이터를 보낼 때도 비슷한 이슈에 직면한다.
    서버는 여러 클라이언트에 대한 많은 커넥션을 가질 수 있다.

> 서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의해서 다룰 필요가 있다.</br>비지속적인 커넥션이라면, 서버는 모든 메시지를 전송했을 때 자신쪽의 커넥션을 닫을 것이다.

### 7단계: 로깅
    마지막으로, 트랜젝션이 완료되었을 떄 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다.